classdef Consistency < regularization.TaylorBased
    methods(Access = protected)
        function assemble_matrix_private(obj)
            assemble_matrix_private@regularization.TaylorBased(obj);
            if ~obj.model_is_taylor
                return
            end
            if ~(...
                    all(obj.model.n_order > 0) &&...
                    (...
                    all(obj.model.sigma_order > 0) ||...
                    all(obj.model.z_order > 0) ...
                    ) ...
                    )
                % This condition may be relaxed a bit.
                warning('Consistency:TaylorOrderTooLow',...
                    ['No consistency matrix assembled: order of Taylor',...
                    'expansions too low.'])
                return
            end

            const_names = obj.get_const_names(); % Cell array

            nb = obj.neighbors;
            rows = []; cols = []; terms = [];
            pnames = obj.names_all;
            row_idx = 1;
            [dn, dsig] = obj.dom2dndsig();
            keep_idx = obj.dom2keep_idx();
            for cell_idx = 1:obj.mesh.ncells
                for eq = 1:numel(const_names)
                    col = [obj.findn(pnames, ['cell ',num2str(cell_idx),': d^1u/dy^1', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(nb(1, cell_idx)),': u0', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(nb(3, cell_idx)),': u0', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(cell_idx),': d^1v/dy^1', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(nb(1, cell_idx)),': v0', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(nb(3, cell_idx)),': v0', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(cell_idx),': d^1w/dy^1', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(nb(1, cell_idx)),': w0', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(nb(3, cell_idx)),': w0', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(cell_idx),': d^1u/dsig^1', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(nb(2, cell_idx)),': u0', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(nb(4, cell_idx)),': u0', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(cell_idx),': d^1v/dsig^1', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(nb(2, cell_idx)),': v0', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(nb(4, cell_idx)),': v0', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(cell_idx),': d^1w/dsig^1', const_names{eq}]) , ...
                        obj.findn(pnames, ['cell ',num2str(nb(2, cell_idx)),': w0', const_names{eq}]), ...
                        obj.findn(pnames, ['cell ',num2str(nb(4, cell_idx)),': w0', const_names{eq}])];

                    row = row_idx + [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5]; % Row incremental index, always the same
                    term = [1, -1/(dn(cell_idx)), 1/(dn(cell_idx)),...
                        1, -1/(dn(cell_idx)), 1/(dn(cell_idx)),...
                        1, -1/(dn(cell_idx)), 1/(dn(cell_idx)),...
                        1, -1/(dsig(cell_idx)), 1/(dsig(cell_idx)), 1, -1/(dsig(cell_idx)), 1/(dsig(cell_idx)),...
                        1, -1/(dsig(cell_idx)), 1/(dsig(cell_idx))]; % Value, always the same (but look at order of magnitudes difference between the values...)

                    rows = [rows row(keep_idx{cell_idx})];
                    cols = [cols col(keep_idx{cell_idx})];%(keep_idx{cell_idx})];
                    terms = [terms term(keep_idx{cell_idx})];
                    if ~isempty(rows)
                        row_idx = max(rows) + 1;
                    end
                end
            end
            obj.C = sparse(rows, cols, terms, 6*obj.mesh.ncells*numel(const_names), obj.mesh.ncells*sum(obj.model.npars));
        end

    end
    methods(Access = protected)
        function val = get_min_order(obj)
            nc = obj.model.ncomponents;
            val = zeros([5,nc]);
        end
    end
end